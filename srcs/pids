exit.c:	cur_cmd = msh->cmds->next;
exit.c:		if(msh->fds)
exit.c:			cmd_count = get_cmd_count(msh->cmds);
exit.c:				free(msh->fds[cmd_count - 1]);
here_doc.c:		write(msh->in_fd, line, ft_strlen(line));
here_doc.c:	msh->in_fd = open(here_doc_file, O_CREAT | O_RDWR, 0644);
here_doc.c:	if (msh->in_fd == -1)
here_doc.c:	close(msh->in_fd);
here_doc.c:	msh->in_fd = open(here_doc_file, O_RDWR, 0644);
here_doc.c:	if (msh->in_fd == -1)
here_doc.c:		close(msh->in_fd);
here_doc.c:		msh->in_fd = open(here_doc_file, O_RDWR, 0644);
here_doc.c:		if (msh->in_fd == -1)
unalias.c:	alias = msh->aliases;
unalias.c:		if (alias->next && msh->cmds->next
unalias.c:			&& !ft_strcmp(alias->next->name, msh->cmds->next->token))
unalias.c:	if (msh->cmds->next && !ft_strcmp(msh->cmds->next->token, "-a"))
unalias.c:		free_alias(msh->aliases);
unalias.c:		msh->aliases = 0;
unalias.c:	if (msh->cmds->next && msh->cmds->next->type == ARG)
unalias.c:			msh->cmds->next->token);
pipe.c:		if (msh->fds[i - 1][0] > 2)
pipe.c:			close(msh->fds[i - 1][0]);
pipe.c:		if (msh->fds[i - 1][1] > 2)
pipe.c:			close(msh->fds[i - 1][1]);
pipe.c:	if (msh->fds[i][0] > 2)
pipe.c:		close(msh->fds[i][0]);
pipe.c:	if (msh->fds[i][1] > 2)
pipe.c:		close(msh->fds[i][1]);
pipe.c:	if (msh->cmds->token && (!ft_strcmp(msh->cmds->token, "cd")
pipe.c:			|| !ft_strcmp(msh->cmds->token, "alias")
pipe.c:			|| !ft_strcmp(msh->cmds->token, "unalias")
pipe.c:			|| !ft_strcmp(msh->cmds->token, "exit") || exec_builtin(msh)))
pipe.c:			free(msh->fds[i]);
pipe.c:			msh->fds[i] = 0;
pipe.c:	if (msh->cmds->token)
pipe.c:		env = env_to_char_tab(msh->env);
pipe.c:		execve(msh->cmds->token, cmd_args, env);
pipe.c:	if ((msh->in_type != ARG && msh->in_type != PIPE)
pipe.c:		|| (msh->in_type == PIPE && i > 0))
pipe.c:	if (msh->out_type == PIPE || msh->out_type == RED_O
pipe.c:		|| msh->out_type == RED_O_APP)
pipe.c:		free(msh->fds[i]);
pipe.c:		msh->fds[i] = 0;
pipe.c:		if (msh->fds[i - 1][0] > 2)
pipe.c:			close(msh->fds[i - 1][0]);
pipe.c:		if (msh->fds[i - 1][1] > 2)
pipe.c:			close(msh->fds[i - 1][1]);
pipe.c:		if (msh->fds[i][0] > 2)
pipe.c:			close(msh->fds[i][0]);
pipe.c:		if (msh->fds[i][1] > 2)
pipe.c:			close(msh->fds[i][1]);
pipe.c:	if (msh->in_fd > 2)
pipe.c:		close(msh->in_fd);
pipe.c:	if (msh->out_fd > 2)
pipe.c:		close(msh->out_fd);
exec.c:		if (pipe(msh->fds[i]) == -1)
exec.c:		msh->pids[i] = pid;
exec.c:	msh->fds[i] = ft_calloc(2, sizeof(int *));
exec.c:	if (!msh->fds[i])
exec.c:		get_in_type(msh, msh->cmds);
exec.c:			get_out_type(msh, msh->cmds);
exec.c:		get_out_type(msh, msh->cmds);
exec.c:			get_in_type(msh, msh->cmds);
exec.c:	if (!cmd_is_builtin(msh, msh->cmds->token))
exec.c:	if (!msh->cmds)
exec.c:	cmd_count = get_cmd_count(msh->cmds);
exec.c:	msh->fds = ft_calloc(cmd_count, sizeof(int **));
exec.c:	msh->pids = ft_calloc(cmd_count, sizeof(int *));
exec.c:	if (!msh->pids || !msh->fds)
exec.c:		waitpid(msh->pids[i], &status, 0);
exec.c:		free(msh->fds[i]);
exec.c:		msh->fds[i] = 0;
exec.c:	free(msh->fds);
exec.c:	msh->fds = 0;
exec.c:	free(msh->pids);
export.c:	cmd = msh->cmds;
export.c:		print_env_declare(msh->env);	
export.c:		msh->env = env_add_back(msh->env, name, value);
export.c:				msh->env = tmp_env->next;
export.c:	cmd = msh->cmds;
export.c:	tmp_env = msh->env;
commands.c:	args_count = get_args_count(msh->cmds);
commands.c:	if (!cmd_args || !msh->fds)
commands.c:	cur_cmd = msh->cmds;
commands.c:	cur_cmd = msh->cmds;
commands.c:			msh->in_type = cmd_tmp->type;
commands.c:			msh->cmds = cur_cmd;
commands.c:		msh->in_type = cur_cmd->type;
commands.c:		msh->cmds = cur_cmd;
commands.c:	msh->in_type = msh->cmds->type;
minishellrc.c:			msh->cmds = parse_command(line, msh->env);
minishellrc.c:			free_cmd(msh->cmds);
minishellrc.c:	home = ft_get_env(msh->env, "HOME");
minishellrc.c:			free(msh->env);
input_redirections.c:	if (msh->in_type != PIPE)
input_redirections.c:		if (dup2(msh->in_fd, 0) < 0)
input_redirections.c:		close(msh->in_fd);
input_redirections.c:		if (dup2(msh->fds[i - 1][0], 0) < 0)
input_redirections.c:		if (msh->in_fd != 0)
input_redirections.c:			close(msh->in_fd);
input_redirections.c:		msh->in_fd = open((*cur_cmd)->next->token, O_RDONLY | O_CREAT);
input_redirections.c:		if (msh->in_fd == -1 && !g_return_code)
input_redirections.c:		msh->in_type = cur_cmd->type;
input_redirections.c:	cur_cmd = msh->cmds;
path.c:		path = ft_strjoin(tmp, msh->cmds->token);
path.c:			free(msh->cmds->token);
path.c:			msh->cmds->token = path;
path.c:	paths = split_paths_from_env(msh->env);
path.c:	if (ft_strchr(msh->cmds->token, '/'))
path.c:		ft_printf_fd(2, "%s: command not found\n", msh->cmds->token);
path.c:		free(msh->cmds->token);
path.c:		msh->cmds->token = 0;
main.c:	msh->aliases = alias_add_back(msh->aliases, ft_strdup("ls"), ft_strdup("ls --color=auto"));
main.c:	while (msh->env && commands)
main.c:		prompt = get_prompt(msh->env);
main.c:		msh->cmds = parse_command(commands, msh->env);
main.c:		msh->cmds = handle_alias(msh);
main.c:		free_cmd(msh->cmds);
handle_alias.c:	if (!msh->cmds)
handle_alias.c:	if (msh->cmds->type == ARG)
handle_alias.c:		alias_command = get_alias(msh->aliases, msh->cmds->token);
handle_alias.c:		return (msh->cmds);
handle_alias.c:	res = parse_command(alias_command, msh->env);
handle_alias.c:	tmp->next = msh->cmds->next;
handle_alias.c:	if(msh->cmds)
handle_alias.c:		free(msh->cmds->token);
handle_alias.c:	free(msh->cmds);
alias.c:	if (!msh->cmds->next || msh->cmds->next->type != ARG)
alias.c:		print_aliases(msh->aliases);
alias.c:		name = get_alias_name(msh->cmds->next);
alias.c:		if (ft_strchr(msh->cmds->next->token, '='))
alias.c:			value = get_alias_value(msh->cmds->next);
alias.c:			msh->aliases = alias_add_back(msh->aliases, name, value);
alias.c:			if (get_alias(msh->aliases, name))
alias.c:				ft_printf("alias %s=%s\n", name, get_alias(msh->aliases, name));
builtins.c:		cd(msh->cmds);
builtins.c:		if (!(msh->in_type == PIPE || msh->out_type == PIPE))
builtins.c:	if (!msh->cmds->token)
builtins.c:	if (!ft_strcmp(msh->cmds->token, "echo"))
builtins.c:		g_return_code = echo(msh->cmds->next);
builtins.c:	else if (!ft_strcmp(msh->cmds->token, "ret"))
builtins.c:		g_return_code = ft_atoi(msh->cmds->next->token);
builtins.c:	else if (!ft_strcmp(msh->cmds->token, "env"))
builtins.c:		g_return_code = print_env(msh->env);
builtins.c:	else if (!ft_strcmp(msh->cmds->token, "exit"))
builtins.c:	else if (!ft_strcmp(msh->cmds->token, "pwd"))
builtins.c:	else if (!ft_strcmp(msh->cmds->token, "cd"))
builtins.c:		g_return_code = cd(msh->cmds);
builtins.c:	else if (!ft_strcmp(msh->cmds->token, "alias"))
builtins.c:	else if (!ft_strcmp(msh->cmds->token, "unalias"))
utils.c:		free_env(msh->env);
utils.c:		free_alias(msh->aliases);
utils.c:		free(msh->pids);
utils.c:		free(msh->fds);
utils.c:		free_cmd(msh->cmds);
utils.c:	fd = open(msh->cmds->token, O_DIRECTORY);
utils.c:		ft_printf_fd(2, "minishell: %s: Is a directory\n", msh->cmds->token);
utils.c:	if (access(msh->cmds->token, X_OK) != -1)
utils.c:		ft_printf_fd(2, "minishell: %s: ", msh->cmds->token);
utils.c:		if (access(msh->cmds->token, F_OK) != -1)
output_redirections.c:	if (msh->out_type != PIPE)
output_redirections.c:		if (dup2(msh->out_fd, 1) < 0)
output_redirections.c:		if (dup2(msh->fds[i][1], 1) < 0)
output_redirections.c:	msh->out_type = (*cur_cmd)->type;
output_redirections.c:	if (msh->out_type == RED_O)
output_redirections.c:		msh->out_fd = open((*cur_cmd)->next->token,
output_redirections.c:	if (msh->out_type == RED_O_APP)
output_redirections.c:		msh->out_fd = open((*cur_cmd)->next->token,
output_redirections.c:	if (msh->out_fd == -1)
output_redirections.c:	msh->out_type = ARG;
output_redirections.c:	msh->out_fd = 0;
output_redirections.c:	if (cmds->type && msh->cmds == cmds)
output_redirections.c:		while (msh->cmds->type != ARG && msh->cmds->next->next)
output_redirections.c:			msh->cmds = msh->cmds->next->next;
output_redirections.c:		msh->out_type = ARG;
